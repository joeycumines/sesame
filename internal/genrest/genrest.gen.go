// Package genrest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package genrest

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// EndpointSpec Spec models the endpoint specification, containing configuration around access and usage behavior.
type EndpointSpec struct {
	// Tunnel Tunnel models an endpoint exposed directly over a tunnel provider.
	//
	// TODO might eventually make this configurable (more than one tunnel pattern)
	Tunnel *EndpointTunnel `json:"tunnel,omitempty"`
}

// EndpointTunnel Tunnel models an endpoint exposed directly over a tunnel provider.
//
// TODO might eventually make this configurable (more than one tunnel pattern)
type EndpointTunnel = map[string]interface{}

// GrpcMetadataBin defines model for GrpcMetadataBin.
type GrpcMetadataBin struct {
	Values *[][]byte `json:"values,omitempty"`
}

// GrpcMetadataStr defines model for GrpcMetadataStr.
type GrpcMetadataStr struct {
	Values *[]string `json:"values,omitempty"`
}

// ProxyRequestDial Dial models the initial request routing of a method call.
type ProxyRequestDial struct {
	// ConnMask conn_mask is an optional field mask for ProxyResponse.conn.
	ConnMask *string `json:"connMask,omitempty"`
	Endpoint *string `json:"endpoint,omitempty"`
	Method   *string `json:"method,omitempty"`
}

// ProxyResponseConn Conn is the response to ProxyRequest.dial.
type ProxyResponseConn struct {
	// Endpoint Endpoint is a gRPC service available via a remote.
	Endpoint *V1alpha1Endpoint `json:"endpoint,omitempty"`

	// Namespace Namespace scopes resources in the Sesame API, and is intended to (eventually) facilitate scoped simple auth.
	Namespace *V1alpha1Namespace `json:"namespace,omitempty"`

	// Remote Remote is a network device or other resource that may be accessed by Sesame clients.
	Remote *V1alpha1Remote `json:"remote,omitempty"`
}

// ProtobufAny `Any` contains an arbitrary serialized protocol buffer message along with a
// URL that describes the type of the serialized message.
//
// Protobuf library provides support to pack/unpack Any values in the form
// of utility functions or additional generated methods of the Any type.
//
// Example 1: Pack and unpack a message in C++.
//
//	Foo foo = ...;
//	Any any;
//	any.PackFrom(foo);
//	...
//	if (any.UnpackTo(&foo)) {
//	  ...
//	}
//
// Example 2: Pack and unpack a message in Java.
//
//	   Foo foo = ...;
//	   Any any = Any.pack(foo);
//	   ...
//	   if (any.is(Foo.class)) {
//	     foo = any.unpack(Foo.class);
//	   }
//	   // or ...
//	   if (any.isSameTypeAs(Foo.getDefaultInstance())) {
//	     foo = any.unpack(Foo.getDefaultInstance());
//	   }
//
//	Example 3: Pack and unpack a message in Python.
//
//	   foo = Foo(...)
//	   any = Any()
//	   any.Pack(foo)
//	   ...
//	   if any.Is(Foo.DESCRIPTOR):
//	     any.Unpack(foo)
//	     ...
//
//	Example 4: Pack and unpack a message in Go
//
//	    foo := &pb.Foo{...}
//	    any, err := anypb.New(foo)
//	    if err != nil {
//	      ...
//	    }
//	    ...
//	    foo := &pb.Foo{}
//	    if err := any.UnmarshalTo(foo); err != nil {
//	      ...
//	    }
//
// The pack methods provided by protobuf library will by default use
// 'type.googleapis.com/full.type.name' as the type URL and the unpack
// methods only use the fully qualified type name after the last '/'
// in the type URL, for example "foo.bar.com/x/y.z" will yield type
// name "y.z".
//
// JSON
// ====
// The JSON representation of an `Any` value uses the regular
// representation of the deserialized, embedded message, with an
// additional field `@type` which contains the type URL. Example:
//
//	package google.profile;
//	message Person {
//	  string first_name = 1;
//	  string last_name = 2;
//	}
//
//	{
//	  "@type": "type.googleapis.com/google.profile.Person",
//	  "firstName": <string>,
//	  "lastName": <string>
//	}
//
// If the embedded message type is well-known and has a custom JSON
// representation, that representation will be embedded adding a field
// `value` which holds the custom JSON in addition to the `@type`
// field. Example (for message [google.protobuf.Duration][]):
//
//	{
//	  "@type": "type.googleapis.com/google.protobuf.Duration",
//	  "value": "1.212s"
//	}
type ProtobufAny struct {
	// Type A URL/resource name that uniquely identifies the type of the serialized
	// protocol buffer message. This string must contain at least
	// one "/" character. The last segment of the URL's path must represent
	// the fully qualified name of the type (as in
	// `path/google.protobuf.Duration`). The name should be in a canonical form
	// (e.g., leading "." is not accepted).
	//
	// In practice, teams usually precompile into the binary all types that they
	// expect it to use in the context of Any. However, for URLs which use the
	// scheme `http`, `https`, or no scheme, one can optionally set up a type
	// server that maps type URLs to message definitions as follows:
	//
	// * If no scheme is provided, `https` is assumed.
	// * An HTTP GET on the URL must yield a [google.protobuf.Type][]
	//   value in binary format, or produce an error.
	// * Applications are allowed to cache lookup results based on the
	//   URL, or have them precompiled into a binary to avoid any
	//   lookup. Therefore, binary compatibility needs to be preserved
	//   on changes to types. (Use versioned type names to manage
	//   breaking changes.)
	//
	// Note: this functionality is not currently available in the official
	// protobuf release, and it is not used for type URLs beginning with
	// type.googleapis.com.
	//
	// Schemes other than `http`, `https` (or the empty scheme) might be
	// used with implementation specific semantics.
	Type                 *string                           `json:"@type,omitempty"`
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// RpcStatus The `Status` type defines a logical error model that is suitable for
// different programming environments, including REST APIs and RPC APIs. It is
// used by [gRPC](https://github.com/grpc). Each `Status` message contains
// three pieces of data: error code, error message, and error details.
//
// You can find out more about this error model and how to work with it in the
// [API Design Guide](https://cloud.google.com/apis/design/errors).
type RpcStatus struct {
	// Code The status code, which should be an enum value of
	// [google.rpc.Code][google.rpc.Code].
	Code *int32 `json:"code,omitempty"`

	// Details A list of messages that carry the error details.  There is a common set of
	// message types for APIs to use.
	Details *[]ProtobufAny `json:"details,omitempty"`

	// Message A developer-facing error message, which should be in English. Any
	// user-facing error message should be localized and sent in the
	// [google.rpc.Status.details][google.rpc.Status.details] field, or localized
	// by the client.
	Message *string `json:"message,omitempty"`
}

// TypeGrpcMetadata GrpcMetadata represents gRPC request or response (header, trailer) metadata.
type TypeGrpcMetadata struct {
	Data *map[string]TypeGrpcMetadataValue `json:"data,omitempty"`
}

// TypeGrpcMetadataValue defines model for typeGrpcMetadataValue.
type TypeGrpcMetadataValue struct {
	Bin *GrpcMetadataBin `json:"bin,omitempty"`
	Str *GrpcMetadataStr `json:"str,omitempty"`
}

// V1alpha1Endpoint Endpoint is a gRPC service available via a remote.
type V1alpha1Endpoint struct {
	CreateTime  *time.Time `json:"createTime,omitempty"`
	Description *string    `json:"description,omitempty"`
	DisplayName *string    `json:"displayName,omitempty"`
	Name        *string    `json:"name,omitempty"`

	// Spec Spec models the endpoint specification, containing configuration around access and usage behavior.
	Spec *EndpointSpec `json:"spec,omitempty"`
}

// V1alpha1ListEndpointsResponse defines model for v1alpha1ListEndpointsResponse.
type V1alpha1ListEndpointsResponse struct {
	Endpoints     *[]V1alpha1Endpoint `json:"endpoints,omitempty"`
	NextPageToken *string             `json:"nextPageToken,omitempty"`
}

// V1alpha1ListRemotesResponse defines model for v1alpha1ListRemotesResponse.
type V1alpha1ListRemotesResponse struct {
	NextPageToken *string           `json:"nextPageToken,omitempty"`
	Remotes       *[]V1alpha1Remote `json:"remotes,omitempty"`
}

// V1alpha1Namespace Namespace scopes resources in the Sesame API, and is intended to (eventually) facilitate scoped simple auth.
type V1alpha1Namespace struct {
	Name *string `json:"name,omitempty"`
}

// V1alpha1ProxyRequest defines model for v1alpha1ProxyRequest.
type V1alpha1ProxyRequest struct {
	// Content `Any` contains an arbitrary serialized protocol buffer message along with a
	// URL that describes the type of the serialized message.
	//
	// Protobuf library provides support to pack/unpack Any values in the form
	// of utility functions or additional generated methods of the Any type.
	//
	// Example 1: Pack and unpack a message in C++.
	//
	//     Foo foo = ...;
	//     Any any;
	//     any.PackFrom(foo);
	//     ...
	//     if (any.UnpackTo(&foo)) {
	//       ...
	//     }
	//
	// Example 2: Pack and unpack a message in Java.
	//
	//     Foo foo = ...;
	//     Any any = Any.pack(foo);
	//     ...
	//     if (any.is(Foo.class)) {
	//       foo = any.unpack(Foo.class);
	//     }
	//     // or ...
	//     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
	//       foo = any.unpack(Foo.getDefaultInstance());
	//     }
	//
	//  Example 3: Pack and unpack a message in Python.
	//
	//     foo = Foo(...)
	//     any = Any()
	//     any.Pack(foo)
	//     ...
	//     if any.Is(Foo.DESCRIPTOR):
	//       any.Unpack(foo)
	//       ...
	//
	//  Example 4: Pack and unpack a message in Go
	//
	//      foo := &pb.Foo{...}
	//      any, err := anypb.New(foo)
	//      if err != nil {
	//        ...
	//      }
	//      ...
	//      foo := &pb.Foo{}
	//      if err := any.UnmarshalTo(foo); err != nil {
	//        ...
	//      }
	//
	// The pack methods provided by protobuf library will by default use
	// 'type.googleapis.com/full.type.name' as the type URL and the unpack
	// methods only use the fully qualified type name after the last '/'
	// in the type URL, for example "foo.bar.com/x/y.z" will yield type
	// name "y.z".
	//
	// JSON
	// ====
	// The JSON representation of an `Any` value uses the regular
	// representation of the deserialized, embedded message, with an
	// additional field `@type` which contains the type URL. Example:
	//
	//     package google.profile;
	//     message Person {
	//       string first_name = 1;
	//       string last_name = 2;
	//     }
	//
	//     {
	//       "@type": "type.googleapis.com/google.profile.Person",
	//       "firstName": <string>,
	//       "lastName": <string>
	//     }
	//
	// If the embedded message type is well-known and has a custom JSON
	// representation, that representation will be embedded adding a field
	// `value` which holds the custom JSON in addition to the `@type`
	// field. Example (for message [google.protobuf.Duration][]):
	//
	//     {
	//       "@type": "type.googleapis.com/google.protobuf.Duration",
	//       "value": "1.212s"
	//     }
	Content *ProtobufAny `json:"content,omitempty"`

	// Dial Dial models the initial request routing of a method call.
	Dial *ProxyRequestDial `json:"dial,omitempty"`

	// Header GrpcMetadata represents gRPC request or response (header, trailer) metadata.
	Header *TypeGrpcMetadata `json:"header,omitempty"`
}

// V1alpha1ProxyResponse defines model for v1alpha1ProxyResponse.
type V1alpha1ProxyResponse struct {
	// Conn Conn is the response to ProxyRequest.dial.
	Conn *ProxyResponseConn `json:"conn,omitempty"`

	// Content `Any` contains an arbitrary serialized protocol buffer message along with a
	// URL that describes the type of the serialized message.
	//
	// Protobuf library provides support to pack/unpack Any values in the form
	// of utility functions or additional generated methods of the Any type.
	//
	// Example 1: Pack and unpack a message in C++.
	//
	//     Foo foo = ...;
	//     Any any;
	//     any.PackFrom(foo);
	//     ...
	//     if (any.UnpackTo(&foo)) {
	//       ...
	//     }
	//
	// Example 2: Pack and unpack a message in Java.
	//
	//     Foo foo = ...;
	//     Any any = Any.pack(foo);
	//     ...
	//     if (any.is(Foo.class)) {
	//       foo = any.unpack(Foo.class);
	//     }
	//     // or ...
	//     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
	//       foo = any.unpack(Foo.getDefaultInstance());
	//     }
	//
	//  Example 3: Pack and unpack a message in Python.
	//
	//     foo = Foo(...)
	//     any = Any()
	//     any.Pack(foo)
	//     ...
	//     if any.Is(Foo.DESCRIPTOR):
	//       any.Unpack(foo)
	//       ...
	//
	//  Example 4: Pack and unpack a message in Go
	//
	//      foo := &pb.Foo{...}
	//      any, err := anypb.New(foo)
	//      if err != nil {
	//        ...
	//      }
	//      ...
	//      foo := &pb.Foo{}
	//      if err := any.UnmarshalTo(foo); err != nil {
	//        ...
	//      }
	//
	// The pack methods provided by protobuf library will by default use
	// 'type.googleapis.com/full.type.name' as the type URL and the unpack
	// methods only use the fully qualified type name after the last '/'
	// in the type URL, for example "foo.bar.com/x/y.z" will yield type
	// name "y.z".
	//
	// JSON
	// ====
	// The JSON representation of an `Any` value uses the regular
	// representation of the deserialized, embedded message, with an
	// additional field `@type` which contains the type URL. Example:
	//
	//     package google.profile;
	//     message Person {
	//       string first_name = 1;
	//       string last_name = 2;
	//     }
	//
	//     {
	//       "@type": "type.googleapis.com/google.profile.Person",
	//       "firstName": <string>,
	//       "lastName": <string>
	//     }
	//
	// If the embedded message type is well-known and has a custom JSON
	// representation, that representation will be embedded adding a field
	// `value` which holds the custom JSON in addition to the `@type`
	// field. Example (for message [google.protobuf.Duration][]):
	//
	//     {
	//       "@type": "type.googleapis.com/google.protobuf.Duration",
	//       "value": "1.212s"
	//     }
	Content *ProtobufAny `json:"content,omitempty"`

	// Error The `Status` type defines a logical error model that is suitable for
	// different programming environments, including REST APIs and RPC APIs. It is
	// used by [gRPC](https://github.com/grpc). Each `Status` message contains
	// three pieces of data: error code, error message, and error details.
	//
	// You can find out more about this error model and how to work with it in the
	// [API Design Guide](https://cloud.google.com/apis/design/errors).
	Error *RpcStatus `json:"error,omitempty"`

	// Header GrpcMetadata represents gRPC request or response (header, trailer) metadata.
	Header *TypeGrpcMetadata `json:"header,omitempty"`

	// Trailer GrpcMetadata represents gRPC request or response (header, trailer) metadata.
	Trailer *TypeGrpcMetadata `json:"trailer,omitempty"`
}

// V1alpha1Remote Remote is a network device or other resource that may be accessed by Sesame clients.
type V1alpha1Remote struct {
	CreateTime  *time.Time `json:"createTime,omitempty"`
	Description *string    `json:"description,omitempty"`
	DisplayName *string    `json:"displayName,omitempty"`
	Name        *string    `json:"name,omitempty"`
}

// SesameListEndpointsParams defines parameters for SesameListEndpoints.
type SesameListEndpointsParams struct {
	PageSize  *int32  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// SesameCreateEndpointParams defines parameters for SesameCreateEndpoint.
type SesameCreateEndpointParams struct {
	// ResourceId May be specified to request a specific (non-trailing) resource id, note it's a single path segment, w/o any "/".
	ResourceId *string `form:"resourceId,omitempty" json:"resourceId,omitempty"`
}

// SesameListRemotesParams defines parameters for SesameListRemotes.
type SesameListRemotesParams struct {
	PageSize  *int32  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// SesameCreateRemoteParams defines parameters for SesameCreateRemote.
type SesameCreateRemoteParams struct {
	// ResourceId May be specified to request a specific (non-trailing) resource id, note it's a single path segment, w/o any "/".
	ResourceId *string `form:"resourceId,omitempty" json:"resourceId,omitempty"`
}

// SesameProxyJSONRequestBody defines body for SesameProxy for application/json ContentType.
type SesameProxyJSONRequestBody = V1alpha1ProxyRequest

// SesameUpdateEndpointJSONRequestBody defines body for SesameUpdateEndpoint for application/json ContentType.
type SesameUpdateEndpointJSONRequestBody = V1alpha1Endpoint

// SesameUpdateRemoteJSONRequestBody defines body for SesameUpdateRemote for application/json ContentType.
type SesameUpdateRemoteJSONRequestBody = V1alpha1Remote

// SesameCreateEndpointJSONRequestBody defines body for SesameCreateEndpoint for application/json ContentType.
type SesameCreateEndpointJSONRequestBody = V1alpha1Endpoint

// SesameCreateRemoteJSONRequestBody defines body for SesameCreateRemote for application/json ContentType.
type SesameCreateRemoteJSONRequestBody = V1alpha1Remote

// Getter for additional properties for ProtobufAny. Returns the specified
// element and whether it was found
func (a ProtobufAny) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProtobufAny
func (a *ProtobufAny) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProtobufAny to handle AdditionalProperties
func (a *ProtobufAny) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["@type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading '@type': %w", err)
		}
		delete(object, "@type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProtobufAny to handle AdditionalProperties
func (a ProtobufAny) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Type != nil {
		object["@type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SesameProxy request with any body
	SesameProxyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SesameProxy(ctx context.Context, body SesameProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SesameDeleteEndpoint request
	SesameDeleteEndpoint(ctx context.Context, name1 string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SesameGetEndpoint request
	SesameGetEndpoint(ctx context.Context, name1 string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SesameUpdateEndpoint request with any body
	SesameUpdateEndpointWithBody(ctx context.Context, name1 string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SesameUpdateEndpoint(ctx context.Context, name1 string, body SesameUpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SesameDeleteRemote request
	SesameDeleteRemote(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SesameGetRemote request
	SesameGetRemote(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SesameUpdateRemote request with any body
	SesameUpdateRemoteWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SesameUpdateRemote(ctx context.Context, name string, body SesameUpdateRemoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SesameListEndpoints request
	SesameListEndpoints(ctx context.Context, parent string, params *SesameListEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SesameCreateEndpoint request with any body
	SesameCreateEndpointWithBody(ctx context.Context, parent string, params *SesameCreateEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SesameCreateEndpoint(ctx context.Context, parent string, params *SesameCreateEndpointParams, body SesameCreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SesameListRemotes request
	SesameListRemotes(ctx context.Context, parent string, params *SesameListRemotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SesameCreateRemote request with any body
	SesameCreateRemoteWithBody(ctx context.Context, parent string, params *SesameCreateRemoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SesameCreateRemote(ctx context.Context, parent string, params *SesameCreateRemoteParams, body SesameCreateRemoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SesameProxyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameProxyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameProxy(ctx context.Context, body SesameProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameProxyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameDeleteEndpoint(ctx context.Context, name1 string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameDeleteEndpointRequest(c.Server, name1)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameGetEndpoint(ctx context.Context, name1 string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameGetEndpointRequest(c.Server, name1)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameUpdateEndpointWithBody(ctx context.Context, name1 string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameUpdateEndpointRequestWithBody(c.Server, name1, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameUpdateEndpoint(ctx context.Context, name1 string, body SesameUpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameUpdateEndpointRequest(c.Server, name1, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameDeleteRemote(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameDeleteRemoteRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameGetRemote(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameGetRemoteRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameUpdateRemoteWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameUpdateRemoteRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameUpdateRemote(ctx context.Context, name string, body SesameUpdateRemoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameUpdateRemoteRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameListEndpoints(ctx context.Context, parent string, params *SesameListEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameListEndpointsRequest(c.Server, parent, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameCreateEndpointWithBody(ctx context.Context, parent string, params *SesameCreateEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameCreateEndpointRequestWithBody(c.Server, parent, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameCreateEndpoint(ctx context.Context, parent string, params *SesameCreateEndpointParams, body SesameCreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameCreateEndpointRequest(c.Server, parent, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameListRemotes(ctx context.Context, parent string, params *SesameListRemotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameListRemotesRequest(c.Server, parent, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameCreateRemoteWithBody(ctx context.Context, parent string, params *SesameCreateRemoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameCreateRemoteRequestWithBody(c.Server, parent, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SesameCreateRemote(ctx context.Context, parent string, params *SesameCreateRemoteParams, body SesameCreateRemoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSesameCreateRemoteRequest(c.Server, parent, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSesameProxyRequest calls the generic SesameProxy builder with application/json body
func NewSesameProxyRequest(server string, body SesameProxyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSesameProxyRequestWithBody(server, "application/json", bodyReader)
}

// NewSesameProxyRequestWithBody generates requests for SesameProxy with any type of body
func NewSesameProxyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/proxy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSesameDeleteEndpointRequest generates requests for SesameDeleteEndpoint
func NewSesameDeleteEndpointRequest(server string, name1 string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name_1", runtime.ParamLocationPath, name1)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSesameGetEndpointRequest generates requests for SesameGetEndpoint
func NewSesameGetEndpointRequest(server string, name1 string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name_1", runtime.ParamLocationPath, name1)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSesameUpdateEndpointRequest calls the generic SesameUpdateEndpoint builder with application/json body
func NewSesameUpdateEndpointRequest(server string, name1 string, body SesameUpdateEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSesameUpdateEndpointRequestWithBody(server, name1, "application/json", bodyReader)
}

// NewSesameUpdateEndpointRequestWithBody generates requests for SesameUpdateEndpoint with any type of body
func NewSesameUpdateEndpointRequestWithBody(server string, name1 string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name_1", runtime.ParamLocationPath, name1)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSesameDeleteRemoteRequest generates requests for SesameDeleteRemote
func NewSesameDeleteRemoteRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSesameGetRemoteRequest generates requests for SesameGetRemote
func NewSesameGetRemoteRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSesameUpdateRemoteRequest calls the generic SesameUpdateRemote builder with application/json body
func NewSesameUpdateRemoteRequest(server string, name string, body SesameUpdateRemoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSesameUpdateRemoteRequestWithBody(server, name, "application/json", bodyReader)
}

// NewSesameUpdateRemoteRequestWithBody generates requests for SesameUpdateRemote with any type of body
func NewSesameUpdateRemoteRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSesameListEndpointsRequest generates requests for SesameListEndpoints
func NewSesameListEndpointsRequest(server string, parent string, params *SesameListEndpointsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent", runtime.ParamLocationPath, parent)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/%s/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSesameCreateEndpointRequest calls the generic SesameCreateEndpoint builder with application/json body
func NewSesameCreateEndpointRequest(server string, parent string, params *SesameCreateEndpointParams, body SesameCreateEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSesameCreateEndpointRequestWithBody(server, parent, params, "application/json", bodyReader)
}

// NewSesameCreateEndpointRequestWithBody generates requests for SesameCreateEndpoint with any type of body
func NewSesameCreateEndpointRequestWithBody(server string, parent string, params *SesameCreateEndpointParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent", runtime.ParamLocationPath, parent)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/%s/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceId", runtime.ParamLocationQuery, *params.ResourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSesameListRemotesRequest generates requests for SesameListRemotes
func NewSesameListRemotesRequest(server string, parent string, params *SesameListRemotesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent", runtime.ParamLocationPath, parent)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/%s/remotes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSesameCreateRemoteRequest calls the generic SesameCreateRemote builder with application/json body
func NewSesameCreateRemoteRequest(server string, parent string, params *SesameCreateRemoteParams, body SesameCreateRemoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSesameCreateRemoteRequestWithBody(server, parent, params, "application/json", bodyReader)
}

// NewSesameCreateRemoteRequestWithBody generates requests for SesameCreateRemote with any type of body
func NewSesameCreateRemoteRequestWithBody(server string, parent string, params *SesameCreateRemoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent", runtime.ParamLocationPath, parent)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1alpha1/%s/remotes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceId", runtime.ParamLocationQuery, *params.ResourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SesameProxy request with any body
	SesameProxyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SesameProxyResponse, error)

	SesameProxyWithResponse(ctx context.Context, body SesameProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*SesameProxyResponse, error)

	// SesameDeleteEndpoint request
	SesameDeleteEndpointWithResponse(ctx context.Context, name1 string, reqEditors ...RequestEditorFn) (*SesameDeleteEndpointResponse, error)

	// SesameGetEndpoint request
	SesameGetEndpointWithResponse(ctx context.Context, name1 string, reqEditors ...RequestEditorFn) (*SesameGetEndpointResponse, error)

	// SesameUpdateEndpoint request with any body
	SesameUpdateEndpointWithBodyWithResponse(ctx context.Context, name1 string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SesameUpdateEndpointResponse, error)

	SesameUpdateEndpointWithResponse(ctx context.Context, name1 string, body SesameUpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*SesameUpdateEndpointResponse, error)

	// SesameDeleteRemote request
	SesameDeleteRemoteWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SesameDeleteRemoteResponse, error)

	// SesameGetRemote request
	SesameGetRemoteWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SesameGetRemoteResponse, error)

	// SesameUpdateRemote request with any body
	SesameUpdateRemoteWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SesameUpdateRemoteResponse, error)

	SesameUpdateRemoteWithResponse(ctx context.Context, name string, body SesameUpdateRemoteJSONRequestBody, reqEditors ...RequestEditorFn) (*SesameUpdateRemoteResponse, error)

	// SesameListEndpoints request
	SesameListEndpointsWithResponse(ctx context.Context, parent string, params *SesameListEndpointsParams, reqEditors ...RequestEditorFn) (*SesameListEndpointsResponse, error)

	// SesameCreateEndpoint request with any body
	SesameCreateEndpointWithBodyWithResponse(ctx context.Context, parent string, params *SesameCreateEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SesameCreateEndpointResponse, error)

	SesameCreateEndpointWithResponse(ctx context.Context, parent string, params *SesameCreateEndpointParams, body SesameCreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*SesameCreateEndpointResponse, error)

	// SesameListRemotes request
	SesameListRemotesWithResponse(ctx context.Context, parent string, params *SesameListRemotesParams, reqEditors ...RequestEditorFn) (*SesameListRemotesResponse, error)

	// SesameCreateRemote request with any body
	SesameCreateRemoteWithBodyWithResponse(ctx context.Context, parent string, params *SesameCreateRemoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SesameCreateRemoteResponse, error)

	SesameCreateRemoteWithResponse(ctx context.Context, parent string, params *SesameCreateRemoteParams, body SesameCreateRemoteJSONRequestBody, reqEditors ...RequestEditorFn) (*SesameCreateRemoteResponse, error)
}

type SesameProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Error The `Status` type defines a logical error model that is suitable for
		// different programming environments, including REST APIs and RPC APIs. It is
		// used by [gRPC](https://github.com/grpc). Each `Status` message contains
		// three pieces of data: error code, error message, and error details.
		//
		// You can find out more about this error model and how to work with it in the
		// [API Design Guide](https://cloud.google.com/apis/design/errors).
		Error  *RpcStatus             `json:"error,omitempty"`
		Result *V1alpha1ProxyResponse `json:"result,omitempty"`
	}
	JSONDefault *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SesameDeleteEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameDeleteEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameDeleteEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SesameGetEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1alpha1Endpoint
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameGetEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameGetEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SesameUpdateEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1alpha1Endpoint
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameUpdateEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameUpdateEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SesameDeleteRemoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameDeleteRemoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameDeleteRemoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SesameGetRemoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1alpha1Remote
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameGetRemoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameGetRemoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SesameUpdateRemoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1alpha1Remote
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameUpdateRemoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameUpdateRemoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SesameListEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1alpha1ListEndpointsResponse
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameListEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameListEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SesameCreateEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1alpha1Endpoint
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameCreateEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameCreateEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SesameListRemotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1alpha1ListRemotesResponse
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameListRemotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameListRemotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SesameCreateRemoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1alpha1Remote
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r SesameCreateRemoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SesameCreateRemoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SesameProxyWithBodyWithResponse request with arbitrary body returning *SesameProxyResponse
func (c *ClientWithResponses) SesameProxyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SesameProxyResponse, error) {
	rsp, err := c.SesameProxyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameProxyResponse(rsp)
}

func (c *ClientWithResponses) SesameProxyWithResponse(ctx context.Context, body SesameProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*SesameProxyResponse, error) {
	rsp, err := c.SesameProxy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameProxyResponse(rsp)
}

// SesameDeleteEndpointWithResponse request returning *SesameDeleteEndpointResponse
func (c *ClientWithResponses) SesameDeleteEndpointWithResponse(ctx context.Context, name1 string, reqEditors ...RequestEditorFn) (*SesameDeleteEndpointResponse, error) {
	rsp, err := c.SesameDeleteEndpoint(ctx, name1, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameDeleteEndpointResponse(rsp)
}

// SesameGetEndpointWithResponse request returning *SesameGetEndpointResponse
func (c *ClientWithResponses) SesameGetEndpointWithResponse(ctx context.Context, name1 string, reqEditors ...RequestEditorFn) (*SesameGetEndpointResponse, error) {
	rsp, err := c.SesameGetEndpoint(ctx, name1, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameGetEndpointResponse(rsp)
}

// SesameUpdateEndpointWithBodyWithResponse request with arbitrary body returning *SesameUpdateEndpointResponse
func (c *ClientWithResponses) SesameUpdateEndpointWithBodyWithResponse(ctx context.Context, name1 string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SesameUpdateEndpointResponse, error) {
	rsp, err := c.SesameUpdateEndpointWithBody(ctx, name1, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameUpdateEndpointResponse(rsp)
}

func (c *ClientWithResponses) SesameUpdateEndpointWithResponse(ctx context.Context, name1 string, body SesameUpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*SesameUpdateEndpointResponse, error) {
	rsp, err := c.SesameUpdateEndpoint(ctx, name1, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameUpdateEndpointResponse(rsp)
}

// SesameDeleteRemoteWithResponse request returning *SesameDeleteRemoteResponse
func (c *ClientWithResponses) SesameDeleteRemoteWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SesameDeleteRemoteResponse, error) {
	rsp, err := c.SesameDeleteRemote(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameDeleteRemoteResponse(rsp)
}

// SesameGetRemoteWithResponse request returning *SesameGetRemoteResponse
func (c *ClientWithResponses) SesameGetRemoteWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SesameGetRemoteResponse, error) {
	rsp, err := c.SesameGetRemote(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameGetRemoteResponse(rsp)
}

// SesameUpdateRemoteWithBodyWithResponse request with arbitrary body returning *SesameUpdateRemoteResponse
func (c *ClientWithResponses) SesameUpdateRemoteWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SesameUpdateRemoteResponse, error) {
	rsp, err := c.SesameUpdateRemoteWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameUpdateRemoteResponse(rsp)
}

func (c *ClientWithResponses) SesameUpdateRemoteWithResponse(ctx context.Context, name string, body SesameUpdateRemoteJSONRequestBody, reqEditors ...RequestEditorFn) (*SesameUpdateRemoteResponse, error) {
	rsp, err := c.SesameUpdateRemote(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameUpdateRemoteResponse(rsp)
}

// SesameListEndpointsWithResponse request returning *SesameListEndpointsResponse
func (c *ClientWithResponses) SesameListEndpointsWithResponse(ctx context.Context, parent string, params *SesameListEndpointsParams, reqEditors ...RequestEditorFn) (*SesameListEndpointsResponse, error) {
	rsp, err := c.SesameListEndpoints(ctx, parent, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameListEndpointsResponse(rsp)
}

// SesameCreateEndpointWithBodyWithResponse request with arbitrary body returning *SesameCreateEndpointResponse
func (c *ClientWithResponses) SesameCreateEndpointWithBodyWithResponse(ctx context.Context, parent string, params *SesameCreateEndpointParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SesameCreateEndpointResponse, error) {
	rsp, err := c.SesameCreateEndpointWithBody(ctx, parent, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameCreateEndpointResponse(rsp)
}

func (c *ClientWithResponses) SesameCreateEndpointWithResponse(ctx context.Context, parent string, params *SesameCreateEndpointParams, body SesameCreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*SesameCreateEndpointResponse, error) {
	rsp, err := c.SesameCreateEndpoint(ctx, parent, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameCreateEndpointResponse(rsp)
}

// SesameListRemotesWithResponse request returning *SesameListRemotesResponse
func (c *ClientWithResponses) SesameListRemotesWithResponse(ctx context.Context, parent string, params *SesameListRemotesParams, reqEditors ...RequestEditorFn) (*SesameListRemotesResponse, error) {
	rsp, err := c.SesameListRemotes(ctx, parent, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameListRemotesResponse(rsp)
}

// SesameCreateRemoteWithBodyWithResponse request with arbitrary body returning *SesameCreateRemoteResponse
func (c *ClientWithResponses) SesameCreateRemoteWithBodyWithResponse(ctx context.Context, parent string, params *SesameCreateRemoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SesameCreateRemoteResponse, error) {
	rsp, err := c.SesameCreateRemoteWithBody(ctx, parent, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameCreateRemoteResponse(rsp)
}

func (c *ClientWithResponses) SesameCreateRemoteWithResponse(ctx context.Context, parent string, params *SesameCreateRemoteParams, body SesameCreateRemoteJSONRequestBody, reqEditors ...RequestEditorFn) (*SesameCreateRemoteResponse, error) {
	rsp, err := c.SesameCreateRemote(ctx, parent, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSesameCreateRemoteResponse(rsp)
}

// ParseSesameProxyResponse parses an HTTP response from a SesameProxyWithResponse call
func ParseSesameProxyResponse(rsp *http.Response) (*SesameProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Error The `Status` type defines a logical error model that is suitable for
			// different programming environments, including REST APIs and RPC APIs. It is
			// used by [gRPC](https://github.com/grpc). Each `Status` message contains
			// three pieces of data: error code, error message, and error details.
			//
			// You can find out more about this error model and how to work with it in the
			// [API Design Guide](https://cloud.google.com/apis/design/errors).
			Error  *RpcStatus             `json:"error,omitempty"`
			Result *V1alpha1ProxyResponse `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSesameDeleteEndpointResponse parses an HTTP response from a SesameDeleteEndpointWithResponse call
func ParseSesameDeleteEndpointResponse(rsp *http.Response) (*SesameDeleteEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameDeleteEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSesameGetEndpointResponse parses an HTTP response from a SesameGetEndpointWithResponse call
func ParseSesameGetEndpointResponse(rsp *http.Response) (*SesameGetEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameGetEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1alpha1Endpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSesameUpdateEndpointResponse parses an HTTP response from a SesameUpdateEndpointWithResponse call
func ParseSesameUpdateEndpointResponse(rsp *http.Response) (*SesameUpdateEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameUpdateEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1alpha1Endpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSesameDeleteRemoteResponse parses an HTTP response from a SesameDeleteRemoteWithResponse call
func ParseSesameDeleteRemoteResponse(rsp *http.Response) (*SesameDeleteRemoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameDeleteRemoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSesameGetRemoteResponse parses an HTTP response from a SesameGetRemoteWithResponse call
func ParseSesameGetRemoteResponse(rsp *http.Response) (*SesameGetRemoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameGetRemoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1alpha1Remote
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSesameUpdateRemoteResponse parses an HTTP response from a SesameUpdateRemoteWithResponse call
func ParseSesameUpdateRemoteResponse(rsp *http.Response) (*SesameUpdateRemoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameUpdateRemoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1alpha1Remote
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSesameListEndpointsResponse parses an HTTP response from a SesameListEndpointsWithResponse call
func ParseSesameListEndpointsResponse(rsp *http.Response) (*SesameListEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameListEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1alpha1ListEndpointsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSesameCreateEndpointResponse parses an HTTP response from a SesameCreateEndpointWithResponse call
func ParseSesameCreateEndpointResponse(rsp *http.Response) (*SesameCreateEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameCreateEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1alpha1Endpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSesameListRemotesResponse parses an HTTP response from a SesameListRemotesWithResponse call
func ParseSesameListRemotesResponse(rsp *http.Response) (*SesameListRemotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameListRemotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1alpha1ListRemotesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSesameCreateRemoteResponse parses an HTTP response from a SesameCreateRemoteWithResponse call
func ParseSesameCreateRemoteResponse(rsp *http.Response) (*SesameCreateRemoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SesameCreateRemoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1alpha1Remote
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
